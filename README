
         .ooo
          'OOOo
      ~ p ooOOOo tion ~
          .OOO
           oO      % a little
             Oo    % language.
            'O
             `
            (o)
        ___/ /          
       /`    \ 
      /v^  `  ,
     (...v/v^/
      \../::/
       \/::/ 


  ~ potion ~

  This isn't supposed to happen!

  I started playing with Lua's internals and reading
  stuff by Ian Piumarta and Nicolas Cannasse. And I,
  well... I don't know how this happened!

  Turns out making a language is a lovely old time,
  you should try it. If you keep it small, fit the
  VM and the parser and the stdlib all into 10k
  lines, then it's no sweat.

  To be fair, I'd been tinkering with the parser
  for years, though.


  ~ the potion pledge ~

  EVERYTHING IS AN OBJECT.
  However, OBJECTS AREN'T EVERYTHING.


  ~ items to understand ~

  1. A traditional object is a tuple of data
     and methods: (D, M).
     
     D is kept in the object itself.
     M is kept in classes.

  2. In Potion, objects are just D.
  
  3. Every object has an M.

  4. But M can be altered, swapped,
     added to, removed from, whatever.

  5. Objects do not have classes.
     The M is a mixin, a collection
     of methods.

  Example: all strings have a "length"
  method. This method comes with Potion.
  It's in the String mixin.

  6. You can swap out mixins for the span
     of a single source file.

  Example: you could give all strings a
  "backwards" method. But just for the
  code inside your test.pn script.

  7. You can re-mix for the span of a
     single closure.

  To sum up:

  EVERYTHING IS AN OBJECT.
  EVEN MIXINS ARE OBJECTS.
  AND, OF COURSE, CLOSURES ARE OBJECTS.

  However, OBJECTS AREN'T EVERYTHING.
  THEY ARE USELESS WITHOUT MIXINS.


  ~ unique ideas ~

  Potion does have a few unique features.

  * It is two languages in one.

    The language itself is objects and closures.

      Number add = (x): self + x.

    But it also includes a data language.

      Build [html [body [p "TEST" (font="Arial")]]]

    The code and data languages can be interleaved
    over and over again. In a way, I'm trying to find
    a middle ground between s-expressions and stuff like
    E4X. I like that s-expressions are a very light data
    syntax, but I like that E4X clearly looks like data.

    When s-expressions appear in Lisp code, they look
    like code. I think it is nice to distinguish the two.

  * Deeply nested blocks can be closed quickly.
    I don't like significant whitespace, personally.
    But I don't like end end end end.

      10 times (i):
        20 times (j):
          "#(i) x #(j)" print
      i.

    The closing "i." ends the block with the "i" arg.
    If more than one arg is present, use the first arg
    only. If named args are used, use the arg not the name.

      10 times (index=i, step=5):
        20 times (index=j):
          "#(i) x #(j)" print
      i.

    Normally, blocks are closed with a period.

      10 times:
        20 times:
          "Odelay!" print.
      .

  * Elimination of line noise.

    I avoid @, #, $, %, {}.
    Stick with ., |, (), [], =, !, ?. Easier on the eyes.
    These are common punctuations in English.

  * I try to defer to English when it comes to punctuation rules.

    Period means "end". (In other langs it means "method call".)
    Comma breaks up statements.
    Space between messages gives a noun-verb feeling.

      window open (width=400, height=500)

  * Named block args.

      [1, 2, 3] map (item=x, index=i): i display, x + 1.


  ~ license ~

  See COPYING for legal information. It's an MIT license,
  which lets you do anything you want with this. I'm hoping
  that makes it very nice for folks who want to embed a little
  Potion in their app!

